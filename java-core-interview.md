# Java Core Вопросы

### Базовый
+ [Назовите основные пакеты и классы стандартной библиотеки Java](#назовите-основные-пакеты-и-классы-стандартной-библиотеки-java)
+ [Назовите основные аннотации JAX-RS API](#назовите-основные-аннотации-jax-rs-api)
+ [Если писали CRUD server, то расскажите про архитектуру и технологии](#если-писали-crud-server-то-расскажите-про-архитектуру-и-технологии)
+ [Назовите основные структуры данных и их особенности](#назовите-основные-структуры-данных-и-их-особенности)
+ [Расскажите про equals и hashCode](#расскажите-про-equals-и-hashCode)
+ [Назовите основные java паттерны](#назовите-основные-java-паттерны)
+ [Расскажите про stream](#расскажите-про-stream)

### Средний
+ [Расскажите про Java Memory Model](#расскажите-про-java-memory-model)
+ [Расскажите про Mutable и Immutable объекты](#расскажите-про-mutable-и-immutable-объекты)
+ [Расскажите про Garbage Collector](#расскажите-про-garbage-collector)
+ [Расскажите про основные параметры настройки JVM](#расскажите-про-основные-параметры-настройки-jvm)

### Продвинутый
+ [Расскажите про области памяти JVM](#расскажите-про-области-памяти-jvm)
+ [Расскажите про профилирование JVM](#расскажите-про-профилирование-jvm)
+ [Расскажите про работу с хипдампом JVM](#расскажите-про-работу-с-хипдампом-jvm)

# Java Core Ответы

### Назовите основные пакеты и классы стандартной библиотеки Java
+ `java.lang` - импортируется автоматически. 
  + Основные классы: `Object, Class, Integer, String, System, Thread, Runnable, Exception`
+ `java.util` - вспомогательные классы. 
  + Основные классы: `Date, Calendar, Collection, List, Map, Iterator, Random`
+ `java.io` и `java.nio` - работа с вводом-выводом, с файловой системой (nio - каналы, буферы, неблокирующий). 
  + Основные классы `java.io`: `InputStream, OutputStream, Reader, Writer, File`
  + Основные классы `java.nio`: `Buffer, Channel, Selector, Path, Files`
+ `java.math` - работа с длинной арифметикой: `BigDecimal, BigInteger`
+ `java.time` - работа со временем: `Instant, LocalDate(Time), OffserDate(Time), Duration, Period, ZoneId`
+ `java.net` - работа с сетью: `URI, URL, Socket, URLConnection, InetAddress`

[к оглавлению](#Java-Core-Вопросы)

### Назовите основные аннотации JAX-RS API
+ `@Path` - для указания относительного URI ресурса
+ `@GET`, `@POST`, `@PUT`, `@DELETE`,`@HEAD` - для указания типа HTTP запроса, который обрабатывает java метод
+ `@PathParam` - для указания параметра URI, который можно использовать в методе обработчике
+ `@QueryParam` - для указания параметра запроса, который можно использовать в методе обработчике
+ `@FormParam` - для указания form-параметра запроса, который можно использовать в методе обработчике
+ `@Produces` - для указания MIME типа данных, который принимает java обработчик
+ `@Consumes` - для указания MIME типа данных, который отдаёт java обработчик

[к оглавлению](#Java-Core-Вопросы)

### Если писали CRUD server, то расскажите про архитектуру и технологии
+ Архитектура: плюс если расскажет про разделение по слоям (Домен\ДАО\Сервис\Ресурс(Контроллер))
+ Технологии: плюс если расскажет, что выбрал и какие альтернативы (Xml, Json, Hibernate, Jpa, Spring (Boot), Jax-Rs)

[к оглавлению](#Java-Core-Вопросы)

### Назовите основные структуры данных и их особенности
На вершине иерархии в Java Collection Framework располагаются 2 интерфейса: `Collection` и `Map`. Эти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу хранения данных: простые последовательные наборы элементов и наборы пар «ключ — значение» соответственно.

Интерфейс `Collection` расширяют интерфейсы:

+ `List` (список)  Реализации:
  + `ArrayList` - Внутри обычный массив, длина которого автоматически увеличивается при добавлении новых элементов. Элементы пронумерованы, начиная от нуля, к ним можно обратиться по индексу.
  + `LinkedList` (двунаправленный связный список) - состоит из узлов, каждый из которых содержит как собственно данные, так и две ссылки на следующий и предыдущий узел.
  + `Vector` — реализация динамического массива объектов, методы которой синхронизированы.
  + `Stack` — реализация стека LIFO (last-in-first-out).
+ `Set` (сет) описывает неупорядоченную коллекцию, не содержащую повторяющихся элементов. Реализации:
  + `HashSet` - использует HashMap для хранения данных. В качестве ключа и значения используется добавляемый элемент. Из-за особенностей реализации порядок элементов не гарантируется при добавлении.
  + `LinkedHashSet` — гарантирует, что порядок элементов при обходе коллекции будет идентичен порядку добавления элементов.
  + `TreeSet` — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта `Comparator`, либо сохраняет элементы с использованием «natural ordering».
+ `Queue` (очередь) предназначена для хранения элементов с предопределённым способом вставки и извлечения FIFO (first-in-first-out):
  + `PriorityQueue` — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта `Comparator`, либо сохраняет элементы с использованием «natural ordering».
  + `ArrayDeque` — реализация интерфейса `Deque`, который расширяет интерфейс `Queue` методами, позволяющими реализовать конструкцию вида LIFO (last-in-first-out).

Интерфейс `Map` реализован классами:

+ `Hashtable` — хэш-таблица, методы которой синхронизированы. Не позволяет использовать `null` в качестве значения или ключа и не является упорядоченной.
+ `HashMap` — хэш-таблица. Позволяет использовать `null` в качестве значения или ключа и не является упорядоченной.
+ `LinkedHashMap` — упорядоченная реализация хэш-таблицы.
+ `TreeMap` — реализация, основанная на красно-чёрных деревьях. Является упорядоченной и предоставляет возможность управлять порядком элементов в коллекции при помощи объекта `Comparator`, либо сохраняет элементы с использованием «natural ordering».
+ `WeakHashMap` — реализация хэш-таблицы, которая организована с использованием _weak references_ для ключей (сборщик мусора автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элемента нет жёстких ссылок).

[к оглавлению](#Java-Core-Вопросы)

### Расскажите про equals и hashCode
+ Контракт equals
  + _Рефлексивность_ для любого заданного значения x, выражение x.equals(x) должно возвращать true. Заданного — имеется в виду такого, что x != null
  + _Симметричность_ для любых заданных значений x и y, x.equals(y) должно возвращать true только в том случае, когда y.equals(x) возвращает true.
  + _Транзитивность_ для любых заданных значений x, y и z, если x.equals(y) возвращает true и y.equals(z) возвращает true, x.equals(z) должно вернуть значение true.
  + _Согласованность_ для любых заданных значений x и y повторный вызов x.equals(y) будет возвращать значение предыдущего вызова этого метода при условии, что поля, используемые для сравнения этих двух объектов, не изменялись между вызовами.
  + _Сравнение null_ для любого заданного значения x вызов x.equals(null) должен возвращать false.
+ Контракт hashCode:
  + вызов метода hashCode один и более раз над одним и тем же объектом должен возвращать одно и то же хэш-значение, при условии что поля объекта, участвующие в вычислении значения, не изменялись.
  + вызов метода hashCode над двумя объектами должен всегда возвращать одно и то же число, если эти объекты равны (вызов метода equals для этих объектов возвращает true).
  + вызов метода hashCode над двумя неравными между собой объектами должен возвращать разные хэш-значения. Хотя это требование и не является обязательным, следует учитывать, что его выполнение положительно повлияет на производительность работы хэш-таблиц.

+ Методы equals и hashCode необходимо переопределять вместе.

[к оглавлению](#Java-Core-Вопросы)

### Назовите основные java паттерны
+ Абстрактная фабрика (**Abstract factory**) - Класс, который представляет собой интерфейс для создания других классов.
+ Строитель (**Builder**) - Класс, который представляет собой интерфейс для создания сложного объекта.
+ Фабричный метод (**Factory method**) - Делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне.
+ Прототип (**Prototype**) - Определяет интерфейс создания объекта через клонирование другого объекта вместо создания через конструктор.
+ Одиночка (**Singleton**) - Класс, который может иметь только один экземпляр.

[к оглавлению](#Java-Core-Вопросы)

### Расскажите про stream
+ Операции:
  + Промежуточные: filter, map, sorted, peek и т.д. Возвращают Stream.
  + Терминальные: collect, forEach, count, reduce, findFirst, anyMatch и т.д. Возвращают результат стрима и запускают его выполнение.
+ Parallel stream - использует ForkJoinPool.commonPool размером Runtime.getRuntime().availableProcessors() — 1.

[к оглавлению](#Java-Core-Вопросы)

### Расскажите про Java Memory Model
_Модель памяти Java_ описывает поведение потоков в среде исполнения Java. Правила выполнения:
+ Однопоточные программы исполняются псевдопоследовательно. Это значит: в реальности процессор может выполнять несколько операций за такт, заодно изменив их порядок, однако все зависимости по данным остаются, так что поведение не отличается от последовательного.
+ Чтение любой переменной (кроме не-volatile long и double, для которых это правило может не выполняться) выдаст либо значение по умолчанию (ноль), либо что-то, записанное туда другой командой.
+ Остальные события выполняются по порядку, если связаны отношением строгого частичного порядка «выполняется прежде» (англ. happens before).

_«Выполняется прежде»_ (англ. happens before) — отношение строгого частичного порядка введённое между атомарными командами. Оно значит, что вторая команда будет «в курсе» изменений, проведённых первой.
Одно выполняется прежде другого для таких операций (список не полный):
+ Захват монитора, Возврат монитора,
+ Всё, что в том же потоке перед записью в volatile-переменную, и сама запись.
+ volatile-чтение и всё, что после него в том же потоке.
+ Запись в volatile-переменную и последующее считывание её
+ Статическая инициализация
+ Запись в final-поля в конструкторе
+ join потока и пр


[к оглавлению](#Java-Core-Вопросы)

### Расскажите про Mutable и Immutable объекты
Иммутабельный (неизменяемый, immutable) класс — это класс, который после инициализации не может изменить свое состояние.
Чтобы класс был иммутабельным, он должен соответствовать следующим требованиям:
+ Запретите расширение класса – либо объявите его final, либо закройте доступ наследникам ко всем способам мутации, перечисленным в следующих пунктах;
+ Сделайте все поля финальными;
+ Не выставляйте наружу методов-мутаторов, которые меняют состояние;
+ Не отдавайте наружу поля ссылочного изменяемого типа (объекты классов, массивы) – если объект под ссылкой не иммутабельный, должна возвращаться его глубокая копия (defensive copy);
+ Создавайте объект правильно (подробнее в следующем посте).

[к оглавлению](#Java-Core-Вопросы)

### Расскажите про Garbage Collector
+ Большинство сборщиков опирается на слабую гипотезу о поколениях. Гипотеза предполагает, что молодые объекты умирают чаще. Для этого куча делится на регионы по времени жизни объектов – поколения. Сборка мусора в них выполняется раздельно.
+ Cуть алгоритма сборкм мусора в том, что достижимые объекты помечаются и группируются, а недостижимые удаляются.
+ **GC Roots** – то, с чего начинается обход графа объектов на вопрос достижимости. Множество корневых объектов (root set) считается достижимым безусловно.
+ **Stop The World** пауза. Это полная остановка потоков программы для безопасной сборки мусора и других системных операций.

Виды сборщиков мусора и как они влияют на производительность:
+ **Serial** – однопоточный, с поколениями. Дает большой throughput (маленькая сумма задержек);Если в приложении небольшой набор данных (примерно до 100 МБ), и/или оно будет работать на одном процессоре без каких-либо требований к времени задержки.
+ **Parallel** – многопоточный вариант Serial; Если приоритет пиковая производительность приложения, и требования к времени задержки отсутствуют (или допустимы паузы в одну секунду и более).
+ **CMS** (Concurrent Mark-Sweep) – дает меньшую latency (маленькие отдельные паузы), выполняя часть сборки вне Stop The World. Плата за это – меньший throughput. Способ сборки примерно как в предыдущих, работает с поколениями. В Java 9 уже объявлен deprecated;
+ **G1** (Garbage First) – тоже направлен на уменьшение latency. Вместо поколений оперирует регионами; CMS/G1. Если время отклика важнее, чем общая пропускная способность, и паузы при сборке мусора должны быть короче одной секунды.
+ **ZGC**. Если у времени отклика высокий приоритет и/или задействована очень большая куча.
[к оглавлению](#Java-Core-Вопросы)

### Расскажите про основные параметры настройки JVM
+ `-Xms` - установить начальный размер heap Java
+ `-Xmx` - установить максимальный размер heap Java
+ `-Xss` - установить размер стека Java-потока (java thread stack)
+ `-XX:+HeapDumpOnOutOfMemoryError` - сделать дамп хипа при нехватке памяти

[к оглавлению](#Java-Core-Вопросы)

### Расскажите про области памяти JVM
+ **Stack** – место под примитивы и ссылки на объекты (но не сами объекты). Хранит локальные переменные и возвращаемые значения функций. Здесь же хранятся ссылки на объекты пока те конструируются. Все данные в стеке – GC roots. Освобождается сразу на выходе из функции. Принадлежит потоку, размер по-умолчанию указывается параметром виртуальной машины -Xss
+ **PermGen** – В этой области хранятся загруженные классы (экземпляры класса Class<T>). Здесь же с Java 7 хранится пул строк. Изначально размера -XX:PermSize, растет динамически до -XX:MaxPermSize. Не считается частью кучи.
+ **Metaspace** – с Java 8 заменяет permanent generation. Отличие в том, что по умолчанию metaspace ограничен только размерами доступной на машине памяти, но так же как PermGen может быть ограничен, параметром -XX:MaxMetaspaceSize.
+ **Heap** – куча, вся managed-память, в которой хранятся все пользовательские объекты. Все следующие разделы – части кучи. Параметры -Xms, -Xmn и -Xmx устанавливают начальный, минимальный и максимальный размеры хипа соответственно.
+ **Eden**, New **Generation**, **Old Generation** и другие – специфичные для сборщика мусора части кучи, поколения. Могут быть разные, но общий подход сохраняется: долго живущий объект постепенно двигается во всё более старое поколение; сборка мусора в разных поколениях происходит раздельно; чем поколение старше, тем сборка в нём реже, но и дороже.

[к оглавлению](#Java-Core-Вопросы)

### Расскажите про профилирование JVM
Виды профилировщиков: JProfiler, YourKit, VisualVM, Java Mission Control

На примере VisualVM:
 - семплирующий профилировщик (снимает показания через равные промежутки времени)
 - инструментирующий профилировщик (добавляет чекпоинты в код)

[к оглавлению](#Java-Core-Вопросы)

### Расскажите про работу с хипдампом JVM
Как снять хипдамп: 
+ JDK утилиты: jmap, jcmd
+ VisualVM
+ Автоматически -XX:+HeapDumpOnOutOfMemoryError
+ JMX (JConsole либо программно)

Просмотри при помощи Eclipse Memory Analyzer:
+ Объекты занимающие больше всего памяти
+ Граф объектов 
+ Достижимые и недостижимые объекты

[к оглавлению](#Java-Core-Вопросы)
