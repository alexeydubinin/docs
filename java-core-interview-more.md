------------
### Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?
Сначала вызываются все статические блоки в очередности от первого статического блока корневого предка и выше по цепочке иерархии до статических блоков самого класса.

Затем вызываются нестатические блоки инициализации корневого предка, конструктор корневого предка и так далее вплоть до нестатических блоков и конструктора самого класса.

>Parent static block(s) → Child static block(s) → Grandchild static block(s)
>
> → Parent non-static block(s) → Parent constructor →
>
> → Child non-static block(s) → Child constructor →
>
> → Grandchild non-static block(s) → Grandchild constructor

[к оглавлению](#Java-Core-Вопросы)

### Какие типы классов бывают в java?
+ _Top level class_ (Обычный класс):
  + _Abstract class_ (Абстрактный класс);
  + _Final class_ (Финализированный класс).
+ _Interfaces_ (Интерфейс).
+ _Enum_ (Перечисление).
+ _Nested class_ (Вложенный класс):
  + _Static nested class_ (Статический вложенный класс);
  + _Member inner class_ (Простой внутренний класс);
  + _Local inner class_ (Локальный класс);
  + _Anonymous inner class_ (Анонимный класс).

[к оглавлению](#Java-Core-Вопросы)

### Что такое «пул строк»?
__Пул строк__ – это набор строк, хранящийся в _Heap_.

+ Пул строк возможен благодаря неизменяемости строк в Java и реализации идеи интернирования строк;
+ Пул строк помогает экономить память, но по этой же причине создание строки занимает больше времени;
+ Когда для создания строки используются `"`, то сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка на неё;
+ При использовании оператора `new` создаётся новый объект `String`. Затем при помощи метода `intern()` эту строку можно поместить в пул или же получить из пула ссылку на другой объект `String` с таким же значением;

[к оглавлению](#Java-Core-Вопросы)

### Приведите примеры удачного и неудачного использования Optional?
**TODO** Описать подробнее
- get без проверки
- default value
- кидаем свой экспешн
- передача в параметрах

[к оглавлению](#Java-Core-Вопросы)

### В чем разница между статическим и динамическим связыванием в Java?
**TODO** Описать подробнее
- overloading/overriding
- интерфейсы, абстрактный классы, дефолтные методы
- invokestatic, invokevirtual

[к оглавлению](#Java-Core-Вопросы)


### Что такое classpath и как с ним работать?
`Classpath` – это параметр, который указывает приложениям где искать пользовательские классы.
По этому адресу должны быть найдены все классы, для которых не применяются специальные загрузчики. На место поиска стандартных классов JRE этот параметр не влияет.
Кроме непосредственно Java-приложений (команда java), этот параметр применим и для других утилит JDK, таких как javac, javadoc и другие.
Есть два основных способа установки classpath:
+ в переменной окружения ОС CLASSPATH,
+ в аргументе командной строки -cp (синоним -classpath).

Второй способ предпочтительнее, потому что позволяет устанавливать разные значения для разных приложений. Значение по умолчанию – текущая директория.
В параметре передаются пути к jar-файлам и корневым директориям с пакетами. Пути разделяют символом : в параметре командной строки, или же ; в переменной окружения. Чтобы включить все файлы директории, разрешается использовать в конце пути символ *.
Если приложение запускается из jar-файла (java -jar), classpath должен быть указан в его манифесте.

[к оглавлению](#Java-Core-Вопросы)

### Какие существуют базовые параметры тюнинга jvm?
+ `-Xms` - установить начальный размер heap Java
+ `-Xmx` - установить максимальный размер heap Java
+ `-Xss` - установить размер стека Java-потока (java thread stack)
+ `-XX:+HeapDumpOnOutOfMemoryError` - сделать дам хипа при нехватке памяти

[к оглавлению](#Java-Core-Вопросы)

### Что такое Happens-before? Какие особенности использования ключевого слова volatile
**TODO** Описать подробнее
- Кэширование значений
- Атомарность операций
- Reordeing

[к оглавлению](#Java-Core-Вопросы)

### Расскажите о Heap и Stack память в Java. В чем разница между ними?
**TODO** Описать подробнее
- локальная/глобальная видимость
- ораничен/неограничен
- фрагментация

[к оглавлению](#Java-Core-Вопросы)

### Как работает Garbage Collector?
**TODO** Описать подробнее
- разные типы GC
- stop the world
- как сделать утечку памяти
- как найти утечку памяти

[к оглавлению](#Java-Core-Вопросы)

### Расскажите, что вы знаете о разных типах ссылок в java?
**TODO** Описать подробнее
- WeakReference, SoftReference, PhantomReference

[к оглавлению](#Java-Core-Вопросы)

# TODO
Подумать про эти вопросы:
+ [Какие существуют модификаторы доступа?](#Какие-существуют-модификаторы-доступа)
+ [Назовите основные интерфейсы Java Collections Framework и их реализации](#Назовите-основные-интерфейсы-jcf-и-их-реализации)
  **Что такое FunctionInterface и чем он отличается от обычного интерфейса?**
  **Привести пример плохой и хорошей реализации метода hashCode()?**

### Какие существуют модификаторы доступа?
__private__ (приватный): члены класса доступны только внутри класса. Для обозначения используется служебное слово `private`.

__default__, package-private, package level (доступ на уровне пакета): видимость класса/членов класса только внутри пакета. Является модификатором доступа по умолчанию - специальное
обозначение не требуется.

__protected__ (защищённый): члены класса доступны внутри пакета и в наследниках. Для обозначения используется служебное слово `protected`.

__public__ (публичный): класс/члены класса доступны всем. Для обозначения используется служебное слово `public`.

Последовательность модификаторов по возрастанию уровня закрытости: public, protected, default, private.

### Назовите основные интерфейсы JCF и их реализации
На вершине иерархии в Java Collection Framework располагаются 2 интерфейса: `Collection` и `Map`. Эти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу хранения данных: простые последовательные наборы элементов и наборы пар «ключ — значение» соответственно.

Интерфейс `Collection` расширяют интерфейсы:

+ `List` (список) представляет собой коллекцию, в которой допустимы дублирующие значения. Реализации:
  + `ArrayList` - инкапсулирует в себе обычный массив, длина которого автоматически увеличивается при добавлении новых элементов. Элементы такой коллекции пронумерованы, начиная от нуля, к ним можно обратиться по индексу.
  + `LinkedList` (двунаправленный связный список) - состоит из узлов, каждый из которых содержит как собственно данные, так и две ссылки на следующий и предыдущий узел.
  + `Vector` — реализация динамического массива объектов, методы которой синхронизированы.
  + `Stack` — реализация стека LIFO (last-in-first-out).
+ `Set` (сет) описывает неупорядоченную коллекцию, не содержащую повторяющихся элементов. Реализации:
  + `HashSet` - использует HashMap для хранения данных. В качестве ключа и значения используется добавляемый элемент. Из-за особенностей реализации порядок элементов не гарантируется при добавлении.
  + `LinkedHashSet` — гарантирует, что порядок элементов при обходе коллекции будет идентичен порядку добавления элементов.
  + `TreeSet` — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта `Comparator`, либо сохраняет элементы с использованием «natural ordering».
+ `Queue` (очередь) предназначена для хранения элементов с предопределённым способом вставки и извлечения FIFO (first-in-first-out):
  + `PriorityQueue` — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта `Comparator`, либо сохраняет элементы с использованием «natural ordering».
  + `ArrayDeque` — реализация интерфейса `Deque`, который расширяет интерфейс `Queue` методами, позволяющими реализовать конструкцию вида LIFO (last-in-first-out).

Интерфейс `Map` реализован классами:

+ `Hashtable` — хэш-таблица, методы которой синхронизированы. Не позволяет использовать `null` в качестве значения или ключа и не является упорядоченной.
+ `HashMap` — хэш-таблица. Позволяет использовать `null` в качестве значения или ключа и не является упорядоченной.
+ `LinkedHashMap` — упорядоченная реализация хэш-таблицы.
+ `TreeMap` — реализация, основанная на красно-чёрных деревьях. Является упорядоченной и предоставляет возможность управлять порядком элементов в коллекции при помощи объекта `Comparator`, либо сохраняет элементы с использованием «natural ordering».
+ `WeakHashMap` — реализация хэш-таблицы, которая организована с использованием _weak references_ для ключей (сборщик мусора автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элемента нет жёстких ссылок).

**Что такое FunctionInterface и чем он отличается от обычного интерфейса?**
- Один метод
- Используется в лямбдах
- Аннотация @FunctionalInterface
- Какие бывают
- Напиши свою

**Привести пример плохой и хорошей реализации метода hashCode()?**
- константа
- неравномерное распределение
- сломан контракт с equals()

**Что такое Atomic types и зачем они нужны?**
- Атомарные операции
- Оптимистичная блокировка (compareAndSet)
- Практические кейсы


[к оглавлению](#Java-Core-Вопросы)